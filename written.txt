1. (1.8)
Since operating systems can be viewed as an interface between users and hardware, by taking the upper operating systems as the “users”, the lower operating systems should provide an interface to the upper to utilize the real hardware.

In designing the interface, the part connecting to the lower operating systems will make use of the system calls and perhaps some other APIs provided by the lower ones. Since the upper operating systems should control a set of hardware, the interface should provide a set of “hardware” for the upper ones.

Therefore, the design concept to let the operating systems run on the other operating systems can be designing a software which provide the abstract hardware environment and connect the virtual hardware to the upper operating systems to be installed.

2. (1.13)
In my opinion, reliability should possess the highest priority when designing operating systems, since if the system is not reliable, the following properties could not be achieved satisfactorily. For example, if the system can easily break down, even if the computer is super fast, it would need to reboot frequently to continue the tasks, decreasing the overall performance.

Security could be the second important property of the system. I think security could be somewhat relative to reliability. If the system is vulnerable, the malicious attack could make the system unreliable and undermine other properties as well.

As for the third position, I think portability could be a bit more preferable to performance nowadays. The reason is that most computers today are quite fast enough; however, there are a myriad of different computer hardware specifications, and there are still more to come. Without portability, the operating systems could only work on a limited number of machines, and it will consume a lot of effort to make them work on others.

Performance would be the fourth in my view. Although the operating speed of computers are pretty fast now, the tasks that computers are doing are getting more difficult and the workload is getting heavier as well. Continuously improving performance is necessary to complete the future jobs efficiently.

Putting adoption the last does not mean it is not important. The purpose of operating systems should provide a robust and secure environment for users to complete their jobs reliably and efficiently. To let users easily make use of the operating systems should be a goal of operating systems as well. However, I believe that adoption can only be maintained when the previous four properties sustained.

3. (3.1)
Yes, UNIX fork can return an error. Since fork is basically to generate a child process by copying the current process as its parent, it means that the kernel should allocate sufficient memory to accommodate the binary file of the child process and size of the memory should be the same as parent’s. When there is no more memory for the child, there is no way to create the child process. In that case, the parent process should be informed to prevent anticipated errors.

If I designed the function, I would allow an error return as well. If there are no error returns, the parent will need to handle any possible following issues if it needs to coordinate with the child to do something. It should be easier to avoid it at the beginning.

4. (3.2)
Yes, UNIX exec can return an error. The file path given to the exec function could be invalid. That is, the exec function cannot get the binary file to be executed. In that case, the child process will not be overlaid with a new binary code and remain the same as the parent process. The program may want to handle such conditions.

If I designed the function, I would make it possible for exec to return errors. Exec failure should not be programmer’s design. Returning error can help them handle it at the early stage, instead of dealing with it clumsily later.

5. (3.3)
The parent and each child process will continuously fork new child processes until forking failed. After the process get out of the loop because of forking failure, the process will exit. If the scheduling makes the processes execute in turn, one process’s exiting and being released could make it possible for other processes to fork successfully. In that case, the system will have a number of the same processes running, and the number could vary between a number which is the maximum of the number of processes able to run.

6. (3.4)
There must be a child process which has stopped or terminated into the zombie state before the parent process execute wait().

7. (3.7)
ls will be executed to show the content of the directory and the the process will terminate. Because exec will overlay the currently running shell with ls program, and there is no way to go back the shell after ls is done.

8. (3.8)
Presuming all fork() will be successfully done:
Parent has n = 5 (> 0) => fork(): # of processes = 2 (2 * 1)
Both 2 processes have n = 5 => n - 1 = 4
Both 2 processes have n = 4 (> 0) => fork(): # of processes = 4 (2 * 2)
All 4 processes have n = 4 => n - 1 = 3
All 4 processes have n = 3 (> 0) => fork(): # of processes = 8 (4 * 2)
All 8 processes have n = 3 => n - 1 = 2
All 8 processes have n = 2 (> 0) => fork(): # of processes = 16 (8 * 2)
All 16 processes have n = 2 => n - 1 = 1
All 16 processes have n = 1 (> 0) => fork(): # of processes = 32 (16 * 2)
All 32 processes have n = 1 => n - 1 = 0
All 32 processes have n = 0 (!> 0):

At this point, there will be 32 processes running

9. (3.9)
Presuming all fork() will be successfully done:
After the first fork(), the parent and the child processes have their own x = 5.
Then x in the first child process will be added 5, becoming 10 till the end.
For the parent process, it will fork again and create the second child which has x = 5 of its own.
Afterwards, both x of the parent and the second child will be added 10, becoming 15.
Then the parent will add its x with 5 at last.

Therefore, the result should be as follows:
There will be 3 copies of x.
Parent’s x will be 20.
The first child’s x will be 10.
The second child’s x will be 15.

10. (3.10)
Program 1:
6
6

Explain: (Presuming all fork() will be successfully done)
Both the parent and the child will have x = 5 after the first fork(). The parent will wait for the child process after fork(). In the child process, its x will be added 1 and be printed, so the child process will print 6 and then exit. After the child exists, the parent will continue and add 1 to its x and then print 6.

Program 2:
6

Explain: (Presuming all fork() will be successfully done)
Similar to the previous case, but the child process will do nothing but exit directly. Therefore, only the parent process will add the value and then print 6.
